@using System.Collections.Concurrent
@using System.Collections.ObjectModel
@using System.Reactive.Linq
@using BlazorRenderAuto.Client.Entity
@using BlazorRenderAuto.Client.Services
@using DevExpress.Blazor.Internal
@using DevExpress.Blazor.Scheduler.Internal
@using LiteInvest.Entity.PlazaEntity
@using LiteInvest.Entity.ServerEntity
@using Telerik.Blazor.Components
@using Telerik.DataSource
@using Telerik.DataSource.Extensions
@using _Imports = BlazorRenderAuto.Client._Imports
@using GridRowClickEventArgs = Telerik.Blazor.Components.GridRowClickEventArgs

@* @inject ApiDataServiceTest ApiDataServiceTest *@
@inject ApiDataService ApiDataService
@inject JsInteropService jsInteropService
@inject IJSRuntime JSRuntime
@implements IDisposable

@rendermode InteractiveAuto



<style>

	.highlight-row {
	background-color: yellow !important;
	}

	.cardnew {
	height: 800px;
	}
	/* Общие стили для WorkWindow */
	.workwindow-container {
	background-color: #f5f5f5;
	border: 1px solid #ddd;
	border-radius: 5px;
	min-height: 250px;
	}

	.k-table-row{
	font-size:10px;
	line-height:10px;
	}

	.telerik-table {
	padding: 0px;
	}

	.k-grid-md td, .k-grid-md .k-table-td {
	padding-block: 0px !important;
	padding-inline: 0px !important;
	}

	.small-row-height .k-placeholder-line {
	display: none;
	}

	.small-row-height.k-grid td {
	margin: 0;
	padding: 0;
	}


	/* Стили для контейнера с таблицей */
	.table-container {
	height: 90vh;
	scrollbar-width: thin;
	overflow-y: auto; /* Включаем вертикальный скроллинг */
	}

	/* Стили для самой таблицы */
	.telerik-grid {
	width: 100%;
	height: 100%;
	}

	/* Стили для контента таблицы */
	.telerik-grid .k-grid-content {
	overflow-y: auto; /* Включаем вертикальный скроллинг в таблице */
	}

	/* Заголовок WorkWindow */
	.workwindow-container h3 {
	margin-top: 0;
	font-size: 18px;
	color: #333;
	font-weight: bold;
	}

	/* Стили для TileLayout (если нужно стилизовать плитки) */
	.telerik-tilelayout-item {
	min-width: 285px;
	min-height: 285px;
	margin-bottom: 15px;
	}

	.tile-content {
	background-color: #fff;
	border-radius: 5px;
	}

	.k-grid-footer {
	padding-inline-end: 0px !important;
	}

	.dxbl-chart-root .dxbl-chart {
	padding: 0px !important;
	}


	.k-grid-content {
	scrollbar-width: none;
	}

	.k-grid-header {
	padding-inline-end: 0px !important;
	}
	/* Дополнительные улучшения для внешнего вида */
	.telerik-grid .k-header {
	background-color: #f0f0f0;
	color: #333;
	text-align: center;
	font-weight: bold;
	}

	.telerik-grid .k-grid-header {
	border-bottom: 1px solid #ddd;
	}

	.telerik-grid .k-grid-table {
	border-spacing: 0;
	border-collapse: collapse;
	}

	.telerik-grid .k-grid-table td,
	.telerik-grid .k-grid-table th {
	text-align: center;
	border: 1px solid #ddd;
	}

	.k-card-body {
	padding: 0px;
	padding-block: 0 !important;
	padding-inline: 0 !important;
	}
	/*.k-tilelayout-item-header{
	display: none;
	}*/
	.k-grid-content {
	padding: 0px;
	}

	.k-tilelayout-item-body k-card-body {
	padding: 0px;
	}
	/* Убираем паддинги для всего TileLayout */
	.telerik-tilelayout {
	padding: 0;
	}

	.gridlayout-item {
	font-size: 1.2em;
	font-weight: 500;
	text-align: center;
	width: 100%;
	height: 800px;
	text-align: center;
	position: relative;
	z-index: 0;
	display: flex;
	align-items: start;
	justify-content: start;
	}

	.gridlayout-item:before {
	content: " ";
	position: absolute;
	z-index: -1;
	width: 100%;
	height: 100%;
	left: 0;
	top: 0;
	opacity: 0.4;
	}

	.gridlayout-header:before {
	background-color: var(--bs-red);
	}

	.gridlayout-content:before {
	background-color: var(--bs-yellow);
	}

	.gridlayout-left-side-bar:before {
	background-color: var(--bs-green);
	}

	.gridlayout-right-side-bar:before {
	}

	.gridlayout-footer:before {
	background-color: var(--bs-blue);
	opacity: 0.5;
	}

	.dxgrid {
	height: 100%;
	}


	.dxbl-grid {
	--dxbl-grid-font-size: 10px;
	}

	.chart {
	height: 80vh;
	}

	.highlighted-item {
	background-color: var(--bs-danger-bg-subtle)
	}

	.highlighted-item2 {
	background-color: var(--bs-success-bg-subtle)
	}

	.transparent-item {
	background-color: transparent
	}

	.card-body {
	padding: 0;
	}

	.removeOrder {
	flex-shrink: 0;
	cursor: pointer;
	float: right;
	}

	.restVolume {
	display: flex;
	height: 22px;
	}

	.restVolumeSpan {
	flex-shrink: 1;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis
	}

</style> 


<div id="@secutityMain.SpecialHash" tabindex="0">

	<TelerikGridLayout>
		<GridLayoutColumns>
			<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%"/>
			<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%"/>
			<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%" />
		</GridLayoutColumns>

		<GridLayoutRows>
			<Telerik.Blazor.Components.GridLayoutRow />
		</GridLayoutRows>

		<GridLayoutItems>
			<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="1">

				@*  
                <TelerikGrid 
                    @ref="QuotesGrid" Id="@GridTableId" 
                    OnRowClick="@OnRowClickHandler" 
                    RowHeight="10"
                    Height="90vh"
                    Data="@Quotes"
                    TItem="@MarketDepthLevel"
                    ScrollMode="@GridScrollMode.Virtual"
                    PageSize="150">
                    <GridColumns>
                        <GridColumn Width="1fr" Field="@nameof(MarketDepthLevel.Volume)" HeaderClass="d-none" />
                        <GridColumn Width="1fr"  Field="@nameof(MarketDepthLevel.Price)" HeaderClass="d-none" />
                        <GridColumn Width="50px"  Field="@nameof(MarketDepthLevel.RestVolume)" HeaderClass="d-none" />
                    </GridColumns>

                </TelerikGrid> *@


				<TelerikGrid 
				@ref="ClustersGrid" 
				RowHeight="22"
				Height="90vh"
				Data="@ClusterDatas"
				TItem="@ClusterLevel"
				ScrollMode="@GridScrollMode.Virtual"
				PageSize="150">
					<GridColumns>
						<GridColumn Width="1fr" Field="@nameof(ClusterLevel.Price)" HeaderClass="d-none" />
						<GridColumn Width="1fr" Field="@nameof(ClusterLevel.Volume)" HeaderClass="d-none"/>
					</GridColumns>

					<RowTemplate Context="ClusterDatas">
						<td class="@GetClassForClusters(ClusterDatas) price">
							@ClusterDatas.Price.ToString("G29")
						</td>
						<td class="@GetClassForClusters(ClusterDatas)">
							@if (ClusterDatas.Volume != 0)
							{
								@ClusterDatas.Volume
							}
						</td>
					</RowTemplate>

				</TelerikGrid> 



			</Telerik.Blazor.Components.GridLayoutItem>
			<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="2">
				@* <TelerikChart Transitions="false" RenderAs="@RenderingMode.Canvas" @ref="chart" Width="100%">
					<ChartLegend Visible="false"></ChartLegend>

					<ChartSeriesItems>
						<ChartSeries Type="Telerik.Blazor.ChartSeriesType.ScatterLine"
						Data="@Ticks"
						XField="@nameof(TradeApi.IndexForChart)"
						YField="@nameof(TradeApi.Price)"
						>
							<ChartSeriesMarkers
							Background="@(nameof(TradeApi.Side) == Side.Sell.ToString() ? "red" : "green")"
							Size="8">
							</ChartSeriesMarkers>
						</ChartSeries>
					</ChartSeriesItems>


				</TelerikChart> *@
			</Telerik.Blazor.Components.GridLayoutItem>
			<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="3">

				<TelerikGrid 
				@ref="QuotesGrid" Id="@GridTableId" 
				OnRowClick="@OnRowClickHandler" 
				RowHeight="10"
				Height="90vh"
				Data="@Quotes"
				TItem="@MarketDepthLevel"
				ScrollMode="@GridScrollMode.Virtual"
				PageSize="150">
					<GridColumns>
						<GridColumn Width="1fr" Field="@nameof(MarketDepthLevel.Volume)" HeaderClass="d-none" />
						<GridColumn Width="1fr"  Field="@nameof(MarketDepthLevel.Price)" HeaderClass="d-none" />
						<GridColumn Width="50px"  Field="@nameof(MarketDepthLevel.RestVolume)" HeaderClass="d-none" />
					</GridColumns>
					<RowTemplate Context="Quotes">
						<td class="@GetClassForQuote(Quotes)">
							@if (Quotes.Volume != 0)
							{
								@Quotes.Volume
							}
						</td>
						<td class="@GetClassForQuote(Quotes) price">
							@Quotes.Price.ToString("G29")
							@* 	@Quotes.Price.ToString("0") *@
						</td>
						<td class="@GetClassForQuote(Quotes) restVolume">
							<span class="restVolumeSpan">
								@Quotes.RestVolume
							</span>
							@if (Quotes.RestVolume.ToString() != string.Empty)
							{
								<svg class="removeOrder" @onclick="() => RemoveOrderClick(Quotes)" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="-2 -5 15 15">
									<line x1="0" y1="0" x2="10" y2="10" stroke="red" stroke-width="2"/>
									<line x1="0" y1="10" x2="10" y2="0" stroke="red" stroke-width="2"/>
								</svg>
							}
						</td>
					</RowTemplate>
				</TelerikGrid>

			</Telerik.Blazor.Components.GridLayoutItem>
		</GridLayoutItems>
	</TelerikGridLayout>

</div>



@code {


	TelerikGrid<ClusterLevel> clustersgrid;
	ObservableCollection<ClusterLevel> ClusterDatas { get; set; } = new ();

	// public class ClusterData
	// {
	// 	public decimal Volume;
	// 	public DateTime DateTime;

	// 	public ClusterData(decimal volume, DateTime dateTime)
	// 	{
	// 		Volume = volume;
	// 		DateTime = dateTime;
	// 	}
	// }

	// private void UpdateClusterData(decimal volumeSumm)
	// {
	// 	if (ClusterDatas != null && ClusterDatas.Count > 5)
	// 	{
	// 		ClusterDatas.RemoveAt(0);
	// 	}

	// 	ClusterDatas.Add(new ClusterData(volumeSumm, DateTime.Now));
	// 	clustersgrid.Rebind();
	// }

	TelerikChart chart;

	static string plusHotKey = "Equal";
	static string minusHotKey = "Minus";
	static string cancelHotKey = "KeyC";

	[Parameter] public string secHash { get; set; }
	[Parameter] public SecurityApi secutityMain { get; set; }

	/// <summary>
	/// Последний собранный масштаб
	/// </summary>
	private int prevbuildScale { get; set; } = 0;

	private int _scale;
	public int Scale
	{
		get => _scale;
		set
		{
			if (_scale != value)
				OnScaleChanged(value);

			_scale = value;
		}
	}

	private void OnScaleChanged(int newscale)
	{

	}

	// public ObservableCollection<Quote> GridData { get; set; }
	public ObservableCollection<MarketDepthLevel> Quotes { get; set; }
	public ObservableCollection<ClusterLevel> ClustersData { get; set; }

	public ObservableCollection<TradeApi> Ticks { get; set; } = new();

	public List<int?> WebSockets { get; set; }

	public TelerikGrid<MarketDepthLevel> QuotesGrid { get; set; }
	public TelerikGrid<ClusterLevel> ClustersGrid { get; set; }

	private string WindowId { get; set; } = Guid.NewGuid().ToString();
	private string GridTableId { get; set; } = Guid.NewGuid().ToString();

	/// <summary>
	/// Индекс к которому мы должны таблицу откскроллить!
	/// Обновляется на лету
	/// </summary>
	int bestbidIndex { get; set; }

	protected override async Task<Task> OnInitializedAsync()
	{
		Console.WriteLine($"{DateTime.Now} On Initialized secID{secutityMain.id} set WorkWindow");

		//Quotes = new();

		Scale = 1;

		ApiDataService.NewMyOrder += NewMyOrder;
		ApiDataService.NewQuotes += OnNewMarketDepth;
		ApiDataService.NewTicks += OnNewTicks;

		jsInteropService.OnKeyDown += OnKeyDown;
		jsInteropService.OnScroll += OnScroll;
		//сначала подпишемся на ордера

		//TODO: Сделать нормальную подписку на частные ордера

		WebSockets =
        [
            await ApiDataService.SubscribeOrderBook(secutityMain.id),
            await ApiDataService.SubcribeTick(secutityMain.id)
        ];

        return base.OnInitializedAsync();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await JSRuntime.InvokeVoidAsync("getScrollEvent", GridTableId);
			await JSRuntime.InvokeVoidAsync("addHotkeyListener", secutityMain.SpecialHash);
		}
		else
		{

		}
	}

	// public override Task SetParametersAsync(ParameterView parameters)
	// {

	// 	Console.WriteLine($"{DateTime.Now} Re Parameters set WorkWindow");

	// 	return base.SetParametersAsync(parameters);
	// }

	protected override async Task OnParametersSetAsync()
	{
		Console.WriteLine($"{DateTime.Now} On Parameters {secutityMain.id} set WorkWindow");

		base.OnParametersSet();
	}


	/// <summary>
	/// Выставление
	/// или отмена если нажали по той же ячейке.
	/// </summary>
	/// <param name="arg"></param>
	/// <returns></returns>
	private Task OnRowClickHandler(GridRowClickEventArgs arg)
	{
		try
		{
			// var item = (MarketDepthLevel)arg.Item;

			// if (Orders.ContainsKey(item.Price))
			// {
			// 	RemoveOrderClick(item);
			// 	return Task.CompletedTask;
			// }

			// var order = new ClientOrder()
			// {
			// 	SecID = secutityMain.id,
			// 	Side = item.Type,
			// 	Volume = orderVolume,
			// 	Price = item.Price,
			// 	Market = false,
			// };

			// Console.WriteLine($"Sending order price = {order.Price} side = {order.Side}");

			// ApiDataService.SendOrder(order);
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}

		return Task.CompletedTask;
	}

	private void RemoveOrderClick(MarketDepthLevel level)
	{

		// Orders.TryGetValue(level.Price, out var _order);

		// if (_order == null)
		// 	Console.WriteLine("No Order Found in Row");

		// ApiDataService.CancelOrder(_order);


	}


	protected override bool ShouldRender()
	{
		Console.WriteLine($"{DateTime.Now} Should {secutityMain.id} Render WorkWindow");
		return base.ShouldRender();
	}

	DateTime lasttime = DateTime.Now;
	int counter = 0;


	private async Task<Task> AddTickData(TradeApi tick)
	{
		tick.Price = bestbid + counter;

		tick.IndexForChart = counter;

		Ticks.Add(tick);

		try
		{
			if (Ticks.Count > 15) Ticks.RemoveAt(0);
		}
		catch (Exception ex)
		{

		}

		return Task.CompletedTask;

	}

	int lasttradetickTime { get; set; } = -1;

	private void ProcessClusterTick(TradeApi tick)
	{
		var agregatingTime = tick.Time.Minute - tick.Time.Minute % 5;

		//Console.WriteLine($"real time {DateTime.Now} agreagatedtime = {agregatingTime}");

		if (agregatingTime != lasttradetickTime)
		{
			Console.WriteLine($"Time For clusters Updated lastmintime={agregatingTime} timeNow = {lasttradetickTime}");

			foreach (var cluster in ClusterDatas)
			{
				cluster.AskVolume = 0;
				cluster.BidVolume = 0;
			}

			Console.WriteLine($"Cluster Table Empty");

			lasttradetickTime = agregatingTime;
		}

		decimal tickAgregatedLevel = tick.Price - tick.Price % (secutityMain.PriceStep * Scale);

		if (IndexesQuotes.ContainsKey(tickAgregatedLevel))
		{
			var index = IndexesQuotes[tickAgregatedLevel];


			var lastclusterItem = (ClusterLevel) ClusterDatas[index].Clone();

			if (tick.Side == Side.Sell)
				lastclusterItem.AskVolume += tick.Volume;
			if(tick.Side== Side.Buy)
				lastclusterItem.BidVolume += tick.Volume;

			ClusterDatas[index] = lastclusterItem;

			//Console.WriteLine($"Updated level {tickAgregatedLevel} ");
		}
	}

	private async void OnNewTicks(string secID, List<TradeApi> ticks)
	{
		if (secID != secutityMain.id)
			return;

		if (IndexesQuotes.Count != 0 && bestbidIndex!=0)
		{

		//симуляция 
			foreach (var tick in ticks)
			{
				var indexrand = new Random().Next(1, 10);
				var randomdirection = new Random().Next(0, 2);

				ProcessClusterTick(new TradeApi()
				{
					Price = Quotes[bestbidIndex - indexrand].Price,
					Volume = 10,
					Side = randomdirection == 0 ? Side.Buy : Side.Sell,
					Time = DateTime.Now,


				});
            }
        }

    }

	ConcurrentDictionary<decimal, MarketDepthLevel> QuotesDictionary = new();

	/// <summary>
	///Хранит информацию 
	/// </summary>
	Dictionary<decimal, int> IndexesQuotes = new Dictionary<decimal, int>();


    private ObservableCollection<ClusterLevel> BuildEmptyClusterLevels(ObservableCollection<MarketDepthLevel> _initialOrderBook)
    {
        var localclustersbuild = new ObservableCollection<ClusterLevel>();

        foreach (var level in _initialOrderBook)
        {
            localclustersbuild.Add(new ClusterLevel() { Price = level.Price});
        }

        return localclustersbuild;

    }

	private ObservableCollection<MarketDepthLevel> BuildInitialQuotes(decimal bestbid)
	{
		try
		{
			int levels = 500 ;

			//округление
			// var min = (bestbid * 0.7m);

			decimal agrregatedlevel = bestbid - bestbid % (secutityMain.PriceStep * Scale);

			agregatedBestbid = agrregatedlevel;

			//previous 
			// var min = bestbid - levels * secutityMain.PriceStep * Scale;
			// var realmin = min - min % secutityMain.PriceStep * Scale;
			// var max = bestbid + levels * secutityMain.PriceStep;
			// var realmax = max - max % secutityMain.PriceStep;

			//new
			var realmin = agrregatedlevel - levels * secutityMain.PriceStep * Scale;
			var realmax = agrregatedlevel + levels * secutityMain.PriceStep * Scale;

			Console.WriteLine($"secid={secutityMain.id} maxSEC ={secutityMain.PriceLimitHigh} minSEC= {secutityMain.PriceLimitLow} ");
			Console.WriteLine($"secid={secutityMain.id} BESTBID ={bestbid} MIN {realmin} MAX {realmax}");

			int index = 0;

			ObservableCollection<MarketDepthLevel> localQuotesBuild = new();

			// for (decimal i = realmin; i < realmax; i += secutityMain.PriceStep)
			// {
			// 	IndexesQuotes.TryAdd(i, index);
			// 	localQuotesBuild.Add(MarketDepthLevel.GetEmptyLevel(i));
			// 	//LocalQuotesBuild.Add(new MarketDepthLevel() { Ask = 1, Price = i, });
			// 	index++;
			// }

			if(Quotes==null )
				Quotes = new();
			else 
				Quotes.Clear();

			IndexesQuotes.Clear();

			for (decimal i = realmax; i > realmin; i -= secutityMain.PriceStep * Scale)
			{
				IndexesQuotes.TryAdd(i, index);
				localQuotesBuild.Add(MarketDepthLevel.GetEmptyLevel(i));
				//LocalQuotesBuild.Add(new MarketDepthLevel() { Ask = 1, Price = i, });
				index++;
			}

			Console.WriteLine($"{secutityMain.id} Created INITIAL EMPTY QUOTES SCALE {Scale}");

			//Quotes = localQuotesBuild;

			return localQuotesBuild;


			//пришлось засунуть местами плохо работает.. 
			//InvokeAsync(StateHasChanged);

			//QuotesGrid.Rebind();



		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
			return null;

		}

	}

	public decimal agregatedBestbid { get; set; }

	bool skipped = false;

	// public async void ScrollOrderBookTo(int index)
	// {
 //        if (QuotesGrid != null)
 //        {
 //            skipped = true;
 //            var state = QuotesGrid.GetState();
 //            var scrollindex = index - 10;
 //            state.Skip = scrollindex;
 //            Console.WriteLine($"Scrolling to {state.Skip} bestbid={Quotes[index].Price} price = {Quotes[scrollindex].Price}");
 //            await QuotesGrid.SetStateAsync(state);
 //        }
 //    }

    public async void ScrollTo <T>(int index,TelerikGrid <T> _grid)
    {

        if (_grid != null)
        {
            skipped = true;
			var state = _grid.GetState();
            var scrollindex = index - 10;
            state.Skip = scrollindex;

			//TODO: Может выскочить ошибка
            //Console.WriteLine($"Scrolling to {state.Skip} bestbid={Quotes[index].Price} price = {Quotes[scrollindex].Price}");
			await _grid.SetStateAsync(state);
        }

    }


	/// <summary>
	/// Придется сравнивать прошлый вариант с новым. 
	/// </summary>
	/// <param name="newquotes"></param>
	private ConcurrentDictionary<decimal, MarketDepthLevel> ScaleBuilderQuotes(ConcurrentDictionary<decimal, MarketDepthLevel> newquotes)
	{

		//здесь не может быть пустых уровней 
		ConcurrentDictionary<decimal, MarketDepthLevel> QuotesAgregated = new ();
		foreach (var level in newquotes)
		{
			decimal agrregatedlevel = level.Key - level.Key % (secutityMain.PriceStep * Scale);

			//Console.WriteLine($"Agregated Level {agrregatedlevel}");

			if (!QuotesAgregated.ContainsKey(agrregatedlevel))
			{
				QuotesAgregated[agrregatedlevel] = new MarketDepthLevel()
                {
                    Bid = level.Value.Bid,
                    Ask = level.Value.Ask,
                    Price = agrregatedlevel,
                };
			}
			else
			{
				//в середине получается мы постоянно имеет и бид и аск.
				if (level.Value.Type != QuotesAgregated[agrregatedlevel].Type)
				{

				}

				if (level.Value.Type == Side.Buy)
					QuotesAgregated[agrregatedlevel].Bid += level.Value.Bid;

				if (level.Value.Type == Side.Sell)
					QuotesAgregated[agrregatedlevel].Ask += level.Value.Ask;
			}
		}

		return QuotesAgregated;

		#region Для теста того что мы насобрали

		// var sorteddictionary = QuotesAgregated.Values.OrderByDescending(s => s.Price).ToList();
		// foreach (var level in sorteddictionary)
		// {
		//     if (level.Ask!=0 && level.Bid!=0)
		//         Console.WriteLine($"SPECIAL! ");
		//     Console.WriteLine($" BID={level.Bid} ASK ={level.Ask} PRICE = {level.Price}");
		// }


		#endregion

		//теперь мы должны сравнить прошлый и обновить индексы. 

		//CompareOldWithNewAndPlaceIndexes(QuotesAgregated,null);

	}

	//QuotesDictionary - old

	bool logquotes = false;

	private void CompareOldWithNewAndPlaceIndexes
	(ConcurrentDictionary<decimal, MarketDepthLevel> newdictionaryQuotes,
		ConcurrentDictionary<decimal, MarketDepthLevel> oldQuotes , ObservableCollection<MarketDepthLevel> _quotesList)
	{


		foreach (var quoteKey in oldQuotes.Keys.ToList())
		{

			if (!newdictionaryQuotes.ContainsKey(quoteKey))
			{


			//меняем коллекицю внутри цикла
				oldQuotes.TryRemove(quoteKey, out var _);

				//Уровень удален.. 
				//Значит кидаем 0
				if (!IndexesQuotes.ContainsKey(quoteKey))
					continue;

				var indexfound = IndexesQuotes[quoteKey];
				//меняем на нулевой
				_quotesList[indexfound] = MarketDepthLevel.GetEmptyLevel(quoteKey);

				if(logquotes)
				Console.WriteLine($" {secutityMain.id} Level removed {quoteKey} index = {indexfound}");

			}
			else
			{
			//новая котировка
				var freshQuote = newdictionaryQuotes[quoteKey];
				var oldquote = oldQuotes[quoteKey];

				if (oldquote != freshQuote)
				{
					oldQuotes[quoteKey] = freshQuote;

					if (!IndexesQuotes.ContainsKey(quoteKey))
						continue;

						//Поменялась котировочка.. 
					var indexfound = IndexesQuotes[quoteKey];
					_quotesList[indexfound] = freshQuote;

                    if(logquotes)
					Console.WriteLine($" {secutityMain.id} Level Changed! {quoteKey} index = {indexfound}");

				}

			}


		}

		foreach (var quoteKey in newdictionaryQuotes.Keys.ToList())
		{
		//в нашей колекции нет нового уровня... 
			if (!oldQuotes.ContainsKey(quoteKey))
			{
				oldQuotes[quoteKey] = newdictionaryQuotes[quoteKey];

				if (!IndexesQuotes.ContainsKey(quoteKey))
					continue;

				var indexfound = IndexesQuotes[quoteKey];
				_quotesList[indexfound] = newdictionaryQuotes[quoteKey];

                if(logquotes)
				Console.WriteLine($" {secutityMain.id} Level Added! {quoteKey} index = {indexfound}");

			}
		}

	}

	private ConcurrentDictionary<decimal, MarketDepthLevel> BuildMarketDepthDictionary(List<MarketDepthLevel> bids, List<MarketDepthLevel> asks)
	{
		var newdictionaryQuotes = new ConcurrentDictionary<decimal, MarketDepthLevel>();
		foreach (var bid in bids)
		{
			newdictionaryQuotes.TryAdd(bid.Price, bid);
		}

		foreach (var ask in asks)
		{
			newdictionaryQuotes.TryAdd(ask.Price, ask);
		}

		return newdictionaryQuotes;
	}

	public decimal bestbid { get; set; }
   


    private void UpdateBestBidIndex(decimal _bestbid)
	{
		if (IndexesQuotes.ContainsKey(_bestbid))
		{
			bestbidIndex = IndexesQuotes[_bestbid];
		}
	}


	//симуляция погано работает. 
    bool real = false;

	private void OnNewMarketDepth(List<MarketDepthLevel> bids, List<MarketDepthLevel> asks, string secID)
	{
		if (secID != secutityMain.id)
			return;

		var easyDictionaryCurrent = BuildMarketDepthDictionary(bids, asks);

		//из-за погано работающей симуляиции приходится так делать
        if (!real)
        {
            easyDictionaryCurrent = BuildMarketDepthDictionary(asks, bids);
        }

		var newdictionaryQuotes = ScaleBuilderQuotes(easyDictionaryCurrent);

		        

		//поменялся масштаб
		if (prevbuildScale != Scale)
		{
		//Применяем масштаб (даже если 1)
			//строим пустой стакан на всю длину
			var initialquotes= BuildInitialQuotes(real? bids[0].Price : asks[0].Price);
			QuotesDictionary.Clear();

			CompareOldWithNewAndPlaceIndexes(newdictionaryQuotes, QuotesDictionary,initialquotes);

			Quotes = initialquotes;
            InvokeAsync(StateHasChanged).GetAwaiter().GetResult();

			prevbuildScale = Scale;

			UpdateBestBidIndex(agregatedBestbid);
            
			ScrollTo(bestbidIndex,QuotesGrid);
			//ScrollOrderBookTo(bestbidIndex);

			// ---- теперь тоже саоме по кластерам //

            ClusterDatas = new ObservableCollection<ClusterLevel>();
			ClusterDatas = BuildEmptyClusterLevels(initialquotes);

			//ClustersGrid.Rebind();
			InvokeAsync(StateHasChanged).GetAwaiter().GetResult();

            ScrollTo(bestbidIndex,ClustersGrid);

            InvokeAsync(StateHasChanged);

        }
        else
        {
            CompareOldWithNewAndPlaceIndexes(newdictionaryQuotes, QuotesDictionary,Quotes);
        }

        // ------- перенос котировок в словарь ------------//
        UpdateBestBidIndex(agregatedBestbid);

    }

    

    private void NewMyOrder(Order obj)
	{
		//throw new NotImplementedException();
	}


	//------------ графика ------------//


    private string GetClassForClusters(ClusterLevel _clusterLevel)
    {
		if (_clusterLevel.Volume == 0 || _clusterLevel.Volume == null)
        {
            return "transparent-item";
        }

		return _clusterLevel.BidVolume<_clusterLevel.AskVolume ? "highlighted-item" : "highlighted-item2";
    }

	public string GetClassForQuote(MarketDepthLevel quote)
	{

		if (quote.Volume == 0 || quote.Volume == null)
		{
			return "transparent-item";
		}

		return quote.Type == Side.Sell ? "highlighted-item" : "highlighted-item2";

	}

	private void OnKeyDown(string windowId, string keyCode, bool isCtrl, bool isShift)
	{
        try
        {
			if (windowId != secutityMain.SpecialHash)
                return;


            if (keyCode == "KeyM")
            {
				//двигаем в середину

                ScrollTo(bestbidIndex,QuotesGrid);
            }

            if (keyCode == cancelHotKey)
            {
                /* foreach (var order in Orders)
                {
                    ApiDataService.CancelOrder(order.Value);
                } */
            }

            if (keyCode == plusHotKey)
            {
                if (Scale >= 5)
                {
                    var newScale = Scale - 5;

                    if (newScale == 0)
                        Scale = 1;
					else Scale=newScale;

                    Console.WriteLine($"{secutityMain.Isin} New Agregation Step {Scale}");

                }
            }

            if (keyCode == minusHotKey)
            {
                if (Scale == 1)
                    Scale += 4;
					else Scale += 5;
                //UpdateAll();

                Console.WriteLine($"{secutityMain.Isin} New Agregation Step {Scale}");
            }

           /*  if (keyCode == "Backspace")
            {
                JSRuntime.InvokeVoidAsync("scrollToRow", GridTableId, 30);
            } */
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        //Console.WriteLine($"{keyCode} {windowId}");
	}

	int firstVisibleIndex;
	int lastVisibleIndex;

	private void OnScroll(string gridTableId, string firstVisibleRowPrice, string lastVisibleRowPrice, int visibleRowCount)
	{
		if (gridTableId == GridTableId)
		{
			int index = Quotes.FindIndex(q => q.Price.ToString("G29") == firstVisibleRowPrice);
			if (index > -1)
			{
				firstVisibleIndex = index;
			}
			index = Quotes.FindIndex(q => q.Price.ToString("G29") == lastVisibleRowPrice);
			if (index > -1)
			{
				lastVisibleIndex = index;
			}
		}

		Console.WriteLine($"{firstVisibleIndex} {firstVisibleRowPrice}");
		Console.WriteLine($"{lastVisibleIndex} {lastVisibleRowPrice}");
		Console.WriteLine($"Видимые строки {visibleRowCount}");

		//Console.WriteLine($"{windowId}");
	}


	// protected override Task OnParametersSetAsync()
	// {
	// 	GridData = ApiDataServiceTest.GetQuotes();

	// 	ApiDataServiceTest.NewQuoteChange += ProcessQuote;
	// 	ApiDataServiceTest.SubscribeForQuotes("11");

	// 	return base.OnParametersSetAsync();
	// }

	// public void ProcessQuote(QuoteChange q)
	// {
	// 	if (GridData != null)
	// 	{
	// 		GridData[q.section] = q.Quote;
	// 		Console.WriteLine($"updated {q.section} {q.Quote.Price}");
	// 	}
	// }
	public void Dispose()
	{
		Console.WriteLine($"Disposing {secutityMain.id}");

		jsInteropService.OnKeyDown -= OnKeyDown;
		jsInteropService.OnScroll -= OnScroll;

		ApiDataService.NewMyOrder -= NewMyOrder;
		ApiDataService.NewQuotes -= OnNewMarketDepth;
		ApiDataService.NewTicks -= OnNewTicks;

        if (WebSockets != null) 
		foreach (var websocketID in WebSockets)
		{
			ApiDataService.StopWebSocket(websocketID);
		}

	}

   

}
