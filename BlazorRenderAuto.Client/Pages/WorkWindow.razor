@using System.Collections.Concurrent
@using System.Collections.ObjectModel
@using System.Reactive.Linq
@using BlazorRenderAuto.Client.Entity
@using BlazorRenderAuto.Client.Services
@using DevExpress.Blazor.Internal
@using LiteInvest.Entity.PlazaEntity
@using LiteInvest.Entity.ServerEntity
@using Telerik.Blazor.Components
@using Telerik.DataSource
@using Telerik.DataSource.Extensions
@using _Imports = BlazorRenderAuto.Client._Imports
@using GridRowClickEventArgs = Telerik.Blazor.Components.GridRowClickEventArgs

@* @inject ApiDataServiceTest ApiDataServiceTest *@
@inject ApiDataService ApiDataService
@inject JsInteropService jsInteropService
@inject IJSRuntime JSRuntime
@implements IDisposable

@rendermode InteractiveAuto



<style>

	.highlight-row {
	background-color: yellow !important;
	}

	.cardnew {
	height: 800px;
	}
	/* Общие стили для WorkWindow */
	.workwindow-container {
	background-color: #f5f5f5;
	border: 1px solid #ddd;
	border-radius: 5px;
	min-height: 250px;
	}

	.k-table-row{
	font-size:10px;
	line-height:10px;
	}

	.telerik-table {
	padding: 0px;
	}

	.k-grid-md td, .k-grid-md .k-table-td {
	padding-block: 0px !important;
	padding-inline: 0px !important;
	}

	.small-row-height .k-placeholder-line {
	display: none;
	}

	.small-row-height.k-grid td {
	margin: 0;
	padding: 0;
	}


	/* Стили для контейнера с таблицей */
	.table-container {
	height: 90vh;
	scrollbar-width: thin;
	overflow-y: auto; /* Включаем вертикальный скроллинг */
	}

	/* Стили для самой таблицы */
	.telerik-grid {
	width: 100%;
	height: 100%;
	}

	/* Стили для контента таблицы */
	.telerik-grid .k-grid-content {
	overflow-y: auto; /* Включаем вертикальный скроллинг в таблице */
	}

	/* Заголовок WorkWindow */
	.workwindow-container h3 {
	margin-top: 0;
	font-size: 18px;
	color: #333;
	font-weight: bold;
	}

	/* Стили для TileLayout (если нужно стилизовать плитки) */
	.telerik-tilelayout-item {
	min-width: 285px;
	min-height: 285px;
	margin-bottom: 15px;
	}

	.tile-content {
	background-color: #fff;
	border-radius: 5px;
	}

	.k-grid-footer {
	padding-inline-end: 0px !important;
	}

	.dxbl-chart-root .dxbl-chart {
	padding: 0px !important;
	}


	.k-grid-content {
	scrollbar-width: none;
	}

	.k-grid-header {
	padding-inline-end: 0px !important;
	}
	/* Дополнительные улучшения для внешнего вида */
	.telerik-grid .k-header {
	background-color: #f0f0f0;
	color: #333;
	text-align: center;
	font-weight: bold;
	}

	.telerik-grid .k-grid-header {
	border-bottom: 1px solid #ddd;
	}

	.telerik-grid .k-grid-table {
	border-spacing: 0;
	border-collapse: collapse;
	}

	.telerik-grid .k-grid-table td,
	.telerik-grid .k-grid-table th {
	text-align: center;
	border: 1px solid #ddd;
	}

	.k-card-body {
	padding: 0px;
	padding-block: 0 !important;
	padding-inline: 0 !important;
	}
	/*.k-tilelayout-item-header{
	display: none;
	}*/
	.k-grid-content {
	padding: 0px;
	}

	.k-tilelayout-item-body k-card-body {
	padding: 0px;
	}
	/* Убираем паддинги для всего TileLayout */
	.telerik-tilelayout {
	padding: 0;
	}

	.gridlayout-item {
	font-size: 1.2em;
	font-weight: 500;
	text-align: center;
	width: 100%;
	height: 800px;
	text-align: center;
	position: relative;
	z-index: 0;
	display: flex;
	align-items: start;
	justify-content: start;
	}

	.gridlayout-item:before {
	content: " ";
	position: absolute;
	z-index: -1;
	width: 100%;
	height: 100%;
	left: 0;
	top: 0;
	opacity: 0.4;
	}

	.gridlayout-header:before {
	background-color: var(--bs-red);
	}

	.gridlayout-content:before {
	background-color: var(--bs-yellow);
	}

	.gridlayout-left-side-bar:before {
	background-color: var(--bs-green);
	}

	.gridlayout-right-side-bar:before {
	}

	.gridlayout-footer:before {
	background-color: var(--bs-blue);
	opacity: 0.5;
	}

	.dxgrid {
	height: 100%;
	}


	.dxbl-grid {
	--dxbl-grid-font-size: 10px;
	}

	.chart {
	height: 80vh;
	}

	.highlighted-item {
	background-color: var(--bs-danger-bg-subtle)
	}

	.highlighted-item2 {
	background-color: var(--bs-success-bg-subtle)
	}

	.transparent-item {
	background-color: transparent
	}

	.card-body {
	padding: 0;
	}

	.removeOrder {
	flex-shrink: 0;
	cursor: pointer;
	float: right;
	}

	.restVolume {
	display: flex;
	height: 22px;
	}

	.restVolumeSpan {
	flex-shrink: 1;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis
	}

</style> 


<div id="@secutityMain.SpecialHash" tabindex="0">

	<TelerikGridLayout>
		<GridLayoutColumns>
			<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%"/>
			<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%"/>
			<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%" />
		</GridLayoutColumns>

		<GridLayoutRows>
			<Telerik.Blazor.Components.GridLayoutRow />
		</GridLayoutRows>

		<GridLayoutItems>
			<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="1">
				@* ScatterLine Series *@

				<TelerikChart>
					<ChartLegend Visible="false"></ChartLegend>
					
					<ChartSeriesItems>
						<ChartSeries Type="Telerik.Blazor.ChartSeriesType.ScatterLine"
									 Data="@Ticks"
									 Name=""
									 
									 XField="@nameof(TradeApi.Time)"
									 YField="@nameof(TradeApi.Price)">
						</ChartSeries>
					</ChartSeriesItems>

					<ChartXAxes>

						<ChartXAxis Visible="false" Max="100">
							<ChartXAxisTitle Visible="false" Text="Time"></ChartXAxisTitle>
							<ChartXAxisLabels Visible="false" Format="{0}m"></ChartXAxisLabels>
						</ChartXAxis>
					</ChartXAxes>

					<ChartYAxes>
						<ChartYAxis Visible="false" Max="100">
							<ChartYAxisTitle Visible="false" Text="Price"></ChartYAxisTitle>
							<ChartYAxisLabels Visible="false" Format="{0}%"></ChartYAxisLabels>
						</ChartYAxis>

					</ChartYAxes>
				</TelerikChart>
@* 				<TelerikChart>
					<ChartSeriesItems>
						<ChartSeries Type="Telerik.Blazor.ChartSeriesType.ScatterLine"
									 Data="Ticks"
									 
						>
							
						</ChartSeries>
					</ChartSeriesItems>

					<ChartXAxes>

						<ChartXAxis Max="100">
							<ChartXAxisTitle Text="Time"></ChartXAxisTitle>
							<ChartXAxisLabels Format="{0}m"></ChartXAxisLabels>
						</ChartXAxis>
					</ChartXAxes>

					<ChartYAxes>
						<ChartYAxis Max="100">
							<ChartYAxisTitle Text="Charge"></ChartYAxisTitle>
							<ChartYAxisLabels Format="{0}%"></ChartYAxisLabels>
						</ChartYAxis>

					</ChartYAxes>

				</TelerikChart> *@
			</Telerik.Blazor.Components.GridLayoutItem>
			<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="2">
@* 				<DxChart CssClass="chart"
						 CustomizeSeriesPoint="@PrepareSeriesPoint"
						 @ref="Chart"
						 Data="Ticks"
						 Width="100%"
						 LabelOverlap="ChartLabelOverlap.Hide">
					<DxChartLineSeries Name="ticksLineSeries"
									   T="TradeApi"
									   TArgument="DateTime"
									   TValue="decimal"
									   ArgumentField="si => si.Time"
									   ValueField="si => si.Price"
									   HoverMode="ChartContinuousSeriesHoverMode.Series">

						<DxChartLegend Visible="false" />

						<!--<DxChartSeriesPoint Visible="true"
						HoverMode="ChartSeriesPointHoverMode.None" />-->
						<!--<DxChartSeriesLabel Visible="true"
						ValueFormat="ChartElementFormat.Thousands(1)" />-->
					</DxChartLineSeries>

					<DxChartArgumentAxis Visible="false">
						<DxChartAxisLabel Visible="false" />
						<DxChartAxisTick Visible="false" />
						<DxChartAxisMinorTick Visible="false" />
						<DxChartAxisGridLines Visible="true" />
					</DxChartArgumentAxis>

					<DxChartValueAxis Visible="false">
						<DxChartAxisLabel Visible="false" />
						<DxChartAxisTick Visible="false" />
						<DxChartAxisMinorTick Visible="false" />
						<DxChartAxisGridLines Visible="true" />
						<DxChartAxisRange StartValue="@minchart" EndValue="@maxchart" />
					</DxChartValueAxis>
				</DxChart> *@
			</Telerik.Blazor.Components.GridLayoutItem>
			<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="3">

				<TelerikGrid 
				@ref="QuotesGrid" Id="@GridTableId" 
				OnRowClick="@OnRowClickHandler" 
				RowHeight="10"
				Height="90vh"
				Data="@Quotes"
				TItem="@MarketDepthLevel"
				ScrollMode="@GridScrollMode.Virtual"
				PageSize="150">
					<GridColumns>
						<GridColumn Width="1fr" Field="@nameof(MarketDepthLevel.Volume)" HeaderClass="d-none" />
						<GridColumn Width="1fr"  Field="@nameof(MarketDepthLevel.Price)" HeaderClass="d-none" />
						<GridColumn Width="50px"  Field="@nameof(MarketDepthLevel.RestVolume)" HeaderClass="d-none" />
					</GridColumns>
					<RowTemplate Context="Quotes">
						<td class="@GetClassForQuote(Quotes)">
							@if (Quotes.Volume != 0)
							{
								@Quotes.Volume
							}
						</td>
						<td class="@GetClassForQuote(Quotes) price">
							@Quotes.Price.ToString("G29")
							@* 	@Quotes.Price.ToString("0") *@
						</td>
						<td class="@GetClassForQuote(Quotes) restVolume">
							<span class="restVolumeSpan">
								@Quotes.RestVolume
							</span>
							@if (Quotes.RestVolume.ToString() != string.Empty)
							{
								<svg class="removeOrder" @onclick="() => RemoveOrderClick(Quotes)" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="-2 -5 15 15">
									<line x1="0" y1="0" x2="10" y2="10" stroke="red" stroke-width="2"/>
									<line x1="0" y1="10" x2="10" y2="0" stroke="red" stroke-width="2"/>
								</svg>
							}
						</td>
					</RowTemplate>
				</TelerikGrid>

			</Telerik.Blazor.Components.GridLayoutItem>
		</GridLayoutItems>
	</TelerikGridLayout>

</div>



@code {

	public class ModelData
	{
		public int X { get; set; }
		public int Y { get; set; }
	}

	public List<ModelData> Series1Data = new List<ModelData>()
	{
		new ModelData() { X = 10, Y = 10 },
		new ModelData() { X = 15, Y = 20 },
		new ModelData() { X = 20, Y = 25 },
		new ModelData() { X = 32, Y = 40 },
		new ModelData() { X = 43, Y = 50 },
		new ModelData() { X = 55, Y = 60 },
		new ModelData() { X = 60, Y = 70 },
		new ModelData() { X = 70, Y = 80 },
		new ModelData() { X = 90, Y = 100 },
	};

	static string plusHotKey = "Equal";
	static string minusHotKey = "Minus";
	static string cancelHotKey = "KeyC";

	[Parameter] public string secHash { get; set; }
	[Parameter] public SecurityApi secutityMain { get; set; }

	/// <summary>
	/// Последний собранный масштаб
	/// </summary>
	private int prevbuildScale { get; set; } = 0;

	private int _scale;
	public int Scale
	{
		get => _scale;
		set
		{
			if (_scale != value)
				OnScaleChanged(value);

			_scale = value;
		}
	}

	private void OnScaleChanged(int newscale)
	{

	}

	// public ObservableCollection<Quote> GridData { get; set; }
	public ObservableCollection<MarketDepthLevel> Quotes { get; set; }

	public List<int?> WebSockets { get; set; }
	public TelerikGrid<MarketDepthLevel> QuotesGrid { get; set; }

	private string WindowId { get; set; } = Guid.NewGuid().ToString();
	private string GridTableId { get; set; } = Guid.NewGuid().ToString();

	/// <summary>
	/// Индекс к которому мы должны таблицу откскроллить!
	/// Обновляется на лету
	/// </summary>
	int bestbidIndex { get; set; }

	protected override async Task<Task> OnInitializedAsync()
	{
		Console.WriteLine($"{DateTime.Now} On Initialized secID{secutityMain.id} set WorkWindow");

		//Quotes = new();

		Scale = 1;

		ApiDataService.NewMyOrder += NewMyOrder;
		ApiDataService.NewQuotes += OnNewMarketDepth;
		ApiDataService.NewTicks += OnNewTicks;

		jsInteropService.OnKeyDown += OnKeyDown;
		jsInteropService.OnScroll += OnScroll;
		//сначала подпишемся на ордера

		//TODO: Сделать нормальную подписку на частные ордера

		WebSockets = new List<int?>();

		WebSockets.Add(await ApiDataService.SubscribeOrderBook(secutityMain.id));
		WebSockets.Add(await ApiDataService.SubcribeTick(secutityMain.id));

		return base.OnInitializedAsync();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await JSRuntime.InvokeVoidAsync("getScrollEvent", GridTableId);
			await JSRuntime.InvokeVoidAsync("addHotkeyListener", secutityMain.SpecialHash);
		}
		else
		{

		}
	}

	// public override Task SetParametersAsync(ParameterView parameters)
	// {

	// 	Console.WriteLine($"{DateTime.Now} Re Parameters set WorkWindow");

	// 	return base.SetParametersAsync(parameters);
	// }

	protected override async Task OnParametersSetAsync()
	{
		Console.WriteLine($"{DateTime.Now} On Parameters {secutityMain.id} set WorkWindow");

		base.OnParametersSet();
	}


	/// <summary>
	/// Выставление
	/// или отмена если нажали по той же ячейке.
	/// </summary>
	/// <param name="arg"></param>
	/// <returns></returns>
	private Task OnRowClickHandler(GridRowClickEventArgs arg)
	{
		try
		{
			// var item = (MarketDepthLevel)arg.Item;

			// if (Orders.ContainsKey(item.Price))
			// {
			// 	RemoveOrderClick(item);
			// 	return Task.CompletedTask;
			// }

			// var order = new ClientOrder()
			// {
			// 	SecID = secutityMain.id,
			// 	Side = item.Type,
			// 	Volume = orderVolume,
			// 	Price = item.Price,
			// 	Market = false,
			// };

			// Console.WriteLine($"Sending order price = {order.Price} side = {order.Side}");

			// ApiDataService.SendOrder(order);
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}

		return Task.CompletedTask;
	}

	private void RemoveOrderClick(MarketDepthLevel level)
	{

		// Orders.TryGetValue(level.Price, out var _order);

		// if (_order == null)
		// 	Console.WriteLine("No Order Found in Row");

		// ApiDataService.CancelOrder(_order);


	}


	protected override bool ShouldRender()
	{
		Console.WriteLine($"{DateTime.Now} Should {secutityMain.id} Render WorkWindow");
		return base.ShouldRender();
	}

	DateTime lasttime = DateTime.Now;
	int counter = 0;

	public List<TradeApi> Ticks { get; set; } = new List<TradeApi>();

	private void OnNewTicks(string secID, List<TradeApi> ticks)
	{
		if(secID!=secutityMain.id)
			return;

		foreach (var tick in Ticks)
		{
			counter++;


			//tick.Time = dt + TimeSpan.FromSeconds(start);
			tick.Time = lasttime + TimeSpan.FromSeconds(counter);

			Ticks.Add(tick);

			try
			{
				if (Ticks.Count > 15) Ticks.RemoveAt(0);
			}
			catch (Exception ex)
			{

			}
		}
	}

	ConcurrentDictionary<decimal, MarketDepthLevel> QuotesDictionary = new();

	/// <summary>
	///Хранит информацию 
	/// </summary>
	Dictionary<decimal, int> IndexesQuotes = new Dictionary<decimal, int>();


	private void BuildAndRenderInitialQuotes(decimal bestbid)
	{
		try
		{
			int levels = 500 ;

			//округление
			// var min = (bestbid * 0.7m);

			decimal agrregatedlevel = bestbid - bestbid % (secutityMain.PriceStep * Scale);

			//previous 
			// var min = bestbid - levels * secutityMain.PriceStep * Scale;
			// var realmin = min - min % secutityMain.PriceStep * Scale;
			// var max = bestbid + levels * secutityMain.PriceStep;
			// var realmax = max - max % secutityMain.PriceStep;

			//new
			var realmin = agrregatedlevel - levels * secutityMain.PriceStep * Scale;
			var realmax = agrregatedlevel + levels * secutityMain.PriceStep * Scale;

			Console.WriteLine($"secid={secutityMain.id} maxSEC ={secutityMain.PriceLimitHigh} minSEC= {secutityMain.PriceLimitLow} ");
			Console.WriteLine($"secid={secutityMain.id} BESTBID ={bestbid} MIN {realmin} MAX {realmax}");

			int index = 0;

			ObservableCollection<MarketDepthLevel> localQuotesBuild = new();

			// for (decimal i = realmin; i < realmax; i += secutityMain.PriceStep)
			// {
			// 	IndexesQuotes.TryAdd(i, index);
			// 	localQuotesBuild.Add(MarketDepthLevel.GetEmptyLevel(i));
			// 	//LocalQuotesBuild.Add(new MarketDepthLevel() { Ask = 1, Price = i, });
			// 	index++;
			// }

			if(Quotes==null )
				Quotes = new();
			else 
				Quotes.Clear();

			IndexesQuotes.Clear();

			for (decimal i = realmax; i > realmin; i -= secutityMain.PriceStep * Scale)
			{
				IndexesQuotes.TryAdd(i, index);
				localQuotesBuild.Add(MarketDepthLevel.GetEmptyLevel(i));
				//LocalQuotesBuild.Add(new MarketDepthLevel() { Ask = 1, Price = i, });
				index++;
			}

			Quotes = localQuotesBuild;


			//пришлось засунуть местами плохо работает.. 
			InvokeAsync(StateHasChanged);
			Console.WriteLine($"{secutityMain.id} LOADED INITIAL EMPTY QUOTES");

		}
		catch (Exception ex)
		{

		}

	}

	bool skipped = false;

	public async void EasySkip(int index)
	{
		if(QuotesGrid != null)
		{
			skipped = true;
			var state = QuotesGrid.GetState();
			state.Skip = index - 10;
			await QuotesGrid.SetStateAsync(state);
		}
    }

    //смена уровней по хоткею.
	//обновление таблицы соотвветсвенно основной. 
	private void ChangeScale()
	{



	}

	/// <summary>
	/// Придется сравнивать прошлый вариант с новым. 
	/// </summary>
	/// <param name="newquotes"></param>
	private ConcurrentDictionary<decimal, MarketDepthLevel> ScaleBuilderQuotes(ConcurrentDictionary<decimal, MarketDepthLevel> newquotes)
	{

		//здесь не может быть пустых уровней 
		ConcurrentDictionary<decimal, MarketDepthLevel> QuotesAgregated = new ();
		foreach (var level in newquotes)
		{
			decimal agrregatedlevel = level.Key - level.Key % (secutityMain.PriceStep * Scale);

			//Console.WriteLine($"Agregated Level {agrregatedlevel}");

			if (!QuotesAgregated.ContainsKey(agrregatedlevel))
			{
				QuotesAgregated[agrregatedlevel] = new MarketDepthLevel()
                {
                    Bid = level.Value.Bid,
                    Ask = level.Value.Ask,
                    Price = agrregatedlevel,
                };
			}
			else
			{
				//в середине получается мы постоянно имеет и бид и аск.
				if (level.Value.Type != QuotesAgregated[agrregatedlevel].Type)
				{

				}

				if (level.Value.Type == Side.Buy)
					QuotesAgregated[agrregatedlevel].Bid += level.Value.Bid;

				if (level.Value.Type == Side.Sell)
					QuotesAgregated[agrregatedlevel].Ask += level.Value.Ask;
			}
		}

        return QuotesAgregated;

        #region Для теста того что мы насобрали

        // var sorteddictionary = QuotesAgregated.Values.OrderByDescending(s => s.Price).ToList();
        // foreach (var level in sorteddictionary)
        // {
        //     if (level.Ask!=0 && level.Bid!=0)
        //         Console.WriteLine($"SPECIAL! ");
        //     Console.WriteLine($" BID={level.Bid} ASK ={level.Ask} PRICE = {level.Price}");
        // }


        #endregion

        //теперь мы должны сравнить прошлый и обновить индексы. 

        //CompareOldWithNewAndPlaceIndexes(QuotesAgregated,null);

    }

	//QuotesDictionary - old

    private void CompareOldWithNewAndPlaceIndexes
    (ConcurrentDictionary<decimal, MarketDepthLevel> newdictionaryQuotes,
        ConcurrentDictionary<decimal, MarketDepthLevel> oldQuotes )
    {

   
        foreach (var quoteKey in oldQuotes.Keys.ToList())
        {

            if (!newdictionaryQuotes.ContainsKey(quoteKey))
            {


                //меняем коллекицю внутри цикла
                oldQuotes.TryRemove(quoteKey, out var _);

                //Уровень удален.. 
                //Значит кидаем 0
                if (!IndexesQuotes.ContainsKey(quoteKey))
                    continue;

                var indexfound = IndexesQuotes[quoteKey];
                //меняем на нулевой
                Quotes[indexfound] = MarketDepthLevel.GetEmptyLevel(quoteKey);

                //Console.WriteLine($" {secID} Level removed {quoteKey} index = {indexfound}");

            }
            else
            {
                //новая котировка
                var freshQuote = newdictionaryQuotes[quoteKey];
                var oldquote = oldQuotes[quoteKey];

                if (oldquote != freshQuote)
                {
                    oldQuotes[quoteKey] = freshQuote;

                    if (!IndexesQuotes.ContainsKey(quoteKey))
                        continue;

                    //Поменялась котировочка.. 
                    var indexfound = IndexesQuotes[quoteKey];
                    Quotes[indexfound] = freshQuote;

                    //Console.WriteLine($" {secID} Level Changed! {quoteKey} index = {indexfound}");

                }

            }


        }

        foreach (var quoteKey in newdictionaryQuotes.Keys.ToList())
        {
            //в нашей колекции нет нового уровня... 
            if (!oldQuotes.ContainsKey(quoteKey))
            {
                oldQuotes[quoteKey] = newdictionaryQuotes[quoteKey];

                if (!IndexesQuotes.ContainsKey(quoteKey))
                    continue;

                var indexfound = IndexesQuotes[quoteKey];
                Quotes[indexfound] = newdictionaryQuotes[quoteKey];

                //Console.WriteLine($" {secID} Level Added! {quoteKey} index = {indexfound}");

            }
        }

    }

    private ConcurrentDictionary<decimal, MarketDepthLevel> BuildMarketDepthDictionary(List<MarketDepthLevel> bids, List<MarketDepthLevel> asks)
	{
		var newdictionaryQuotes = new ConcurrentDictionary<decimal, MarketDepthLevel>();
		foreach (var bid in bids)
		{
			newdictionaryQuotes.TryAdd(bid.Price, bid);
		}

		foreach (var ask in asks)
		{
			newdictionaryQuotes.TryAdd(ask.Price, ask);
		}

		return newdictionaryQuotes;
	}

	private void OnNewMarketDepth(List<MarketDepthLevel> bids, List<MarketDepthLevel> asks, string secID)
	{
		if (secID != secutityMain.id)
			return;

		var bestbid = bids[0].Price;

		var easyDictionaryCurrent = BuildMarketDepthDictionary(bids, asks);

        var newdictionaryQuotes = ScaleBuilderQuotes(easyDictionaryCurrent);

		//поменялся масштаб
		if (prevbuildScale != Scale)
		{
			//Применяем масштаб (даже если 1)
			//строим пустой стакан на всю длину
            BuildAndRenderInitialQuotes(bids[0].Price);
			QuotesDictionary.Clear();

            CompareOldWithNewAndPlaceIndexes(newdictionaryQuotes, QuotesDictionary);
            prevbuildScale = Scale;
        }
        else
        {
            CompareOldWithNewAndPlaceIndexes(newdictionaryQuotes, QuotesDictionary);
        }


		//Обновление индекса
		if (IndexesQuotes.ContainsKey(bestbid) && !skipped)
		{
			bestbidIndex = IndexesQuotes[bestbid];
			EasySkip(bestbidIndex);
			//Console.WriteLine($" BestBidIndex {bestbidIndex} bestbID= {bestbid}");
        }

		// ------- перенос котировок в словарь ------------//

       

		//изначальная установка
        /* if (Quotes==null)
		{
			QuotesDictionary = newdictionaryQuotes;
			BuildAndRenderInitialQuotes(bids[0].Price);
        }
		else
        {
            CompareOldWithNewAndPlaceIndexes(newdictionaryQuotes, QuotesDictionary);

            //TODO: ВОЗМОЖНО ЕЩЕ НЕ УЧЕЛ Какой то перебор

        }

        ScaleBuilderQuotes(newdictionaryQuotes) */

    }

	private void NewMyOrder(Order obj)
	{
		//throw new NotImplementedException();
	}


	//------------ графика ------------//




	public string GetClassForQuote(MarketDepthLevel quote)
	{

		if (quote.Volume == 0 || quote.Volume == null)
		{
			return "transparent-item";
		}

		return quote.Type == Side.Sell ? "highlighted-item" : "highlighted-item2";

	}

	private void OnKeyDown(string windowId, string keyCode, bool isCtrl, bool isShift)
	{
        try
        {
			if (windowId != secutityMain.SpecialHash)
                return;


            if (keyCode == cancelHotKey)
            {
                /* foreach (var order in Orders)
                {
                    ApiDataService.CancelOrder(order.Value);
                } */
            }

            if (keyCode == plusHotKey)
            {
                if (Scale > 0)
                {
                    Scale -= 5;
                    Console.WriteLine($"{secutityMain.Isin} New Agregation Step {Scale}");

                }
            }

            if (keyCode == minusHotKey)
            {
                Scale += 5;
                //UpdateAll();

                Console.WriteLine($"{secutityMain.Isin} New Agregation Step {Scale}");
            }

           /*  if (keyCode == "Backspace")
            {
                JSRuntime.InvokeVoidAsync("scrollToRow", GridTableId, 30);
            } */
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        //Console.WriteLine($"{keyCode} {windowId}");
	}

	int firstVisibleIndex;
	int lastVisibleIndex;

	private void OnScroll(string gridTableId, string firstVisibleRowPrice, string lastVisibleRowPrice, int visibleRowCount)
	{
		if (gridTableId == GridTableId)
		{
			int index = Quotes.FindIndex(q => q.Price.ToString("G29") == firstVisibleRowPrice);
			if (index > -1)
			{
				firstVisibleIndex = index;
			}
			index = Quotes.FindIndex(q => q.Price.ToString("G29") == lastVisibleRowPrice);
			if (index > -1)
			{
				lastVisibleIndex = index;
			}
		}

		Console.WriteLine($"{firstVisibleIndex} {firstVisibleRowPrice}");
		Console.WriteLine($"{lastVisibleIndex} {lastVisibleRowPrice}");
		Console.WriteLine($"Видимые строки {visibleRowCount}");

		//Console.WriteLine($"{windowId}");
	}


	// protected override Task OnParametersSetAsync()
	// {
	// 	GridData = ApiDataServiceTest.GetQuotes();

	// 	ApiDataServiceTest.NewQuoteChange += ProcessQuote;
	// 	ApiDataServiceTest.SubscribeForQuotes("11");

	// 	return base.OnParametersSetAsync();
	// }

	// public void ProcessQuote(QuoteChange q)
	// {
	// 	if (GridData != null)
	// 	{
	// 		GridData[q.section] = q.Quote;
	// 		Console.WriteLine($"updated {q.section} {q.Quote.Price}");
	// 	}
	// }
	public void Dispose()
	{
		Console.WriteLine($"Disposing {secutityMain.id}");

		jsInteropService.OnKeyDown -= OnKeyDown;
		jsInteropService.OnScroll -= OnScroll;

		ApiDataService.NewMyOrder -= NewMyOrder;
		ApiDataService.NewQuotes -= OnNewMarketDepth;
		ApiDataService.NewTicks -= OnNewTicks;

        if (WebSockets != null) 
		foreach (var websocketID in WebSockets)
		{
			ApiDataService.StopWebSocket(websocketID);
		}

	}

}
