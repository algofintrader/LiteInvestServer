@using System.Collections.Concurrent
@using System.Drawing
@using System.Net.WebSockets
@using DevExpress.Data.Browsing
@using LiteInvestMainFront.Data
@using LiteInvestServer.Json
@using PlazaEngine.Entity
@using Websocket.Client
@using Orientation = DevExpress.Blazor.Orientation
@implements IDisposable;
@inject IJSRuntime JSRuntime

<style>
	.cardnew {
	height: 800px;
	}
	/* Общие стили для WorkWindow */
	.workwindow-container {
	background-color: #f5f5f5;
	border: 1px solid #ddd;
	border-radius: 5px;
	min-height: 250px;
	}

	.telerik-table {
	padding: 0px;
	}

	.k-grid-md td, .k-grid-md .k-table-td {
	padding-block: 0px !important;
	padding-inline: 0px !important;
	}
	/* Стили для контейнера с таблицей */
	.table-container {
	height: 90vh;
	scrollbar-width: thin;
	overflow-y: auto; /* Включаем вертикальный скроллинг */
	}

	/* Стили для самой таблицы */
	.telerik-grid {
	width: 100%;
	height: 100%;
	}

	/* Стили для контента таблицы */
	.telerik-grid .k-grid-content {
	overflow-y: auto; /* Включаем вертикальный скроллинг в таблице */
	}

	/* Заголовок WorkWindow */
	.workwindow-container h3 {
	margin-top: 0;
	font-size: 18px;
	color: #333;
	font-weight: bold;
	}

	/* Стили для TileLayout (если нужно стилизовать плитки) */
	.telerik-tilelayout-item {
	min-width: 285px;
	min-height: 285px;
	margin-bottom: 15px;
	}

	.tile-content {
	background-color: #fff;
	border-radius: 5px;
	}

	.k-grid-content {
	scrollbar-width: none;
	}

	.k-grid-header {
	padding-inline-end: 0px !important;
	}
	/* Дополнительные улучшения для внешнего вида */
	.telerik-grid .k-header {
	background-color: #f0f0f0;
	color: #333;
	text-align: center;
	font-weight: bold;
	}

	.telerik-grid .k-grid-header {
	border-bottom: 1px solid #ddd;
	}

	.telerik-grid .k-grid-table {
	border-spacing: 0;
	border-collapse: collapse;
	}

	.telerik-grid .k-grid-table td,
	.telerik-grid .k-grid-table th {
	text-align: center;
	border: 1px solid #ddd;
	}

	.k-card-body {
	padding: 0px;
	padding-block: 0 !important;
	padding-inline: 0 !important;
	}
	/*.k-tilelayout-item-header{
	display: none;
	}*/
	.k-grid-content {
	padding: 0px;
	}

	.k-tilelayout-item-body k-card-body {
	padding: 0px;
	}
	/* Убираем паддинги для всего TileLayout */
	.telerik-tilelayout {
	padding: 0;
	}

	.gridlayout-item {
	font-size: 1.2em;
	font-weight: 500;
	text-align: center;
	width: 100%;
	height: 800px;
	text-align: center;
	position: relative;
	z-index: 0;
	display: flex;
	align-items: start;
	justify-content: start;
	}

	.gridlayout-item:before {
	content: " ";
	position: absolute;
	z-index: -1;
	width: 100%;
	height: 100%;
	left: 0;
	top: 0;
	opacity: 0.4;
	}

	.gridlayout-header:before {
	background-color: var(--bs-red);
	}

	.gridlayout-content:before {
	background-color: var(--bs-yellow);
	}

	.gridlayout-left-side-bar:before {
	background-color: var(--bs-green);
	}

	.gridlayout-right-side-bar:before {
	}

	.gridlayout-footer:before {
	background-color: var(--bs-blue);
	opacity: 0.5;
	}

	.dxgrid {
	height: 100%;
	}


	.dxbl-grid {
	--dxbl-grid-font-size: 10px;
	}

	.chart {
	height: 80vh;
	}

	.highlighted-item {
	background-color: var(--bs-danger-bg-subtle)
	}

	.transparent-item {
	background-color:transparent
	}

	.card-body {
	padding: 0;
	}

	.highlighted-item2 {
	background-color: var(--bs-success-bg-subtle)
	}

</style>


<TelerikGridLayout>
	<GridLayoutColumns>
		<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%"/>
		<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%"/>
		<Telerik.Blazor.Components.GridLayoutColumn Width="33.33%"/>
	</GridLayoutColumns>

	<GridLayoutRows>
		<Telerik.Blazor.Components.GridLayoutRow />
	</GridLayoutRows>
	<GridLayoutItems>
		<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="1">
			<TelerikGrid  Size="Small" Class="telerik-table" Data="@Quotes">
				<GridColumns>
					<Telerik.Blazor.Components.GridColumn Field="Volume" HeaderClass="d-none" />
					<Telerik.Blazor.Components.GridColumn Field="Price" HeaderClass="d-none" />
				</GridColumns>
			</TelerikGrid>
		</Telerik.Blazor.Components.GridLayoutItem>
		<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="2">

			<DxChart CssClass="chart"
			CustomizeSeriesPoint="@PrepareSeriesPoint"
			@ref="Chart"
			Data="Ticks"
			Width="100%"
			LabelOverlap="ChartLabelOverlap.Hide">
				<DxChartLineSeries Name="ticksLineSeries"
				T="TradeApi"
				TArgument="DateTime"
				TValue="decimal"
				ArgumentField="si => si.Time"
				ValueField="si => si.Price"
				HoverMode="ChartContinuousSeriesHoverMode.Series">

					<DxChartLegend Visible="false" />

					<!--<DxChartSeriesPoint Visible="true"
					HoverMode="ChartSeriesPointHoverMode.None" />-->
					<!--<DxChartSeriesLabel Visible="true"
					ValueFormat="ChartElementFormat.Thousands(1)" />-->
				</DxChartLineSeries>

				<DxChartArgumentAxis Visible="false">
					<DxChartAxisLabel Visible="false" />
					<DxChartAxisTick Visible="false" />
					<DxChartAxisMinorTick Visible="false" />
					<DxChartAxisGridLines Visible="true" />
				</DxChartArgumentAxis>

				<DxChartValueAxis Visible="false">
					<DxChartAxisLabel Visible="false" />
					<DxChartAxisTick Visible="false" />
					<DxChartAxisMinorTick Visible="false" />
					<DxChartAxisGridLines Visible="true" />
					<DxChartAxisRange StartValue="@minchart" EndValue="@maxchart" />
				</DxChartValueAxis>
			</DxChart>
		</Telerik.Blazor.Components.GridLayoutItem>
		<Telerik.Blazor.Components.GridLayoutItem Row="1" Column="3">
			@* 			<DxGrid CssClass="dxgrid"
			@ref=Grid
			Data="@Quotes"
			ShowAllRows="true"
			ColumnResizeMode="GridColumnResizeMode.NextColumn"
			TextWrapEnabled="false"
			CustomizeElement="Grid_CustomizeElement"
			ShowGroupPanel="false"
			HighlightRowOnHover="true"
			FocusedRowEnabled="true">

			<Columns>
			<DxGridDataColumn FieldName="Volume" />
			<DxGridDataColumn FieldName="Price"/>
			<DxGridDataColumn FieldName="Type" Width="0" Visible="false" />
			</Columns>
			</DxGrid> *@
			<TelerikGrid Height="90vh" Resizable="true" Size="Small" Class="telerik-table" Data="@Quotes">
				<GridColumns>
					<Telerik.Blazor.Components.GridColumn Field="Volume" HeaderClass="d-none" />
					<Telerik.Blazor.Components.GridColumn Field="Price" HeaderClass="d-none" />
				</GridColumns>
				<RowTemplate Context="Quotes">
					<td class="@GetClassForQuote(Quotes)">
						@Quotes.Volume
					</td>
					<td class="@GetClassForQuote(Quotes)">
						@Quotes.Price
					</td>
				</RowTemplate>
			</TelerikGrid>
		</Telerik.Blazor.Components.GridLayoutItem>
	</GridLayoutItems>
</TelerikGridLayout>

@*
<div class="card cardnew">
	<div class="card-header">
		@secutityMain.Isin
		<button type="button" class="buttonclose btn-close" aria-label="Close" @onclick="OnClosingMain"></button>
	</div>
	<div class="card-body">

		<DxGridLayout CssClass="w-100 ch-480">
			<Rows>
				<DxGridLayoutRow />
				<DxGridLayoutRow Height="auto" />
			</Rows>
			<Columns>
				<DxGridLayoutColumn />
				<DxGridLayoutColumn />
				<DxGridLayoutColumn />
			</Columns>
			<Items>
				<DxGridLayoutItem Row="0" Column="0">
					<Template>
						<div class="gridlayout-item">
							Clasters
						</div>
					</Template>
				</DxGridLayoutItem>

				<DxGridLayoutItem Row="0" Column="1">
					<Template>
						<div class=" gridlayout-item">
							<DxChart CssClass="chart"
									 CustomizeSeriesPoint="@PrepareSeriesPoint"
									 @ref="Chart"
									 Data="Ticks"
									 Width="100%"
									 LabelOverlap="ChartLabelOverlap.Hide">
								<DxChartLineSeries Name="ticksLineSeries"
												   T="Trade"
												   TArgument="DateTime"
												   TValue="decimal"
												   ArgumentField="si => si.Time"
												   ValueField="si => si.Price"
												   HoverMode="ChartContinuousSeriesHoverMode.Series">

									<DxChartLegend Visible="false" />

									<!--<DxChartSeriesPoint Visible="true"
													HoverMode="ChartSeriesPointHoverMode.None" />-->
									<!--<DxChartSeriesLabel Visible="true"
													ValueFormat="ChartElementFormat.Thousands(1)" />-->
								</DxChartLineSeries>

								<DxChartArgumentAxis Visible="false">

									<DxChartAxisTick Visible="false" />
									<DxChartAxisMinorTick Visible="false" />

									<DxChartAxisGridLines Visible="true" />

								</DxChartArgumentAxis>


								<DxChartValueAxis Visible="false">

									<DxChartAxisTick Visible="false" />
									<DxChartAxisMinorTick Visible="false" />

									<DxChartAxisGridLines Visible="true" />

									<DxChartAxisRange StartValue="@minchart" EndValue="@maxchart" />
								</DxChartValueAxis>
							</DxChart>
						</div>
					</Template>
				</DxGridLayoutItem>

				<DxGridLayoutItem Row="0" Column="2">
					<Template>
						<div class=" gridlayout-item">
							<DxGrid CssClass="dxgrid"
									@ref=Grid
									Data="@Quotes"
									ShowAllRows="true"
									ColumnResizeMode="GridColumnResizeMode.NextColumn"
									TextWrapEnabled="false"
									CustomizeElement="Grid_CustomizeElement"
									ShowGroupPanel="false"
									HighlightRowOnHover="true"
									FocusedRowEnabled="true">

								<Columns>
									<DxGridDataColumn FieldName="Volume" Width="30px" />
									<DxGridDataColumn FieldName="Price" Width="30px" />
									<DxGridDataColumn FieldName="Type" Width="0" Visible="false" />
								</Columns>
							</DxGrid>
						</div>
					</Template>
				</DxGridLayoutItem>
			</Items>
		</DxGridLayout>
	</div>
</div> *@


@code {


		DxChart<TradeApi> Chart;

		IGrid Grid;
		//А вдруг у меня все получится
		//Влруг я буду прав

		[Parameter]
		public BufferData Data { get; set; }

		[Parameter]
		public Action<SecurityApi>? OnClosing { get; set; }

		[Parameter]
		public SecurityApi secutityMain { get; set; }

		[Parameter]
		public ApiDataService ApiDataService { get; set; }

		[Parameter]
		public int Index{ get; set; }

	public List<WebsocketClient> WebSockets { get; set; }

	public string GetClassForQuote(MarketDepthLevel quote)
	{

		if (quote.Volume ==0)
		{
			return "transparent-item";
		}

		return quote.Type == Side.Sell ? "highlighted-item" : "highlighted-item2";

	}

	protected override async Task<Task> OnInitializedAsync()
	{
		if (secutityMain == null)
			return base.OnInitializedAsync();

		WebSockets = new List<WebsocketClient>();

		ApiDataService.NewMarketDepth += OnNewMarketDepth;
		ApiDataService.NewTicks += OnNewTicks;

		WebSockets.Add(await ApiDataService.SubscribeOrderBook(secutityMain.id));
		WebSockets.Add(await ApiDataService.SubcribeTick(secutityMain.id));

		return base.OnInitializedAsync();
	}



	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await JSRuntime.InvokeVoidAsync("getScrollEvent");
		}
	}

	bool agreagate = true;
	int agregation = 5;

	private async void OnNewMarketDepth(MarketDepthLevel bestbid,MarketDepthLevel bestask, string secinstrument, Dictionary<decimal, MarketDepthLevel> md)
	{

		try
		{

			if (secinstrument != secutityMain.id) return;

			if (md == null)
				return;


			var maxlevel = md.Values.ToArray()[0].Price;
			var minlevel = md.Values.ToArray()[md.Count - 1].Price;

			ConcurrentDictionary<decimal, MarketDepthLevel> AgregatedLevels = new();
			if (agreagate)
			{

				
				for (decimal i = bestask.Price; i < maxlevel; i += agregation*secutityMain.PriceStep)
				{
					decimal summ = 0;
					decimal level = i;
					for (decimal j = i; j <= i + agregation * secutityMain.PriceStep; j += secutityMain.PriceStep)
					{
						if (!md.ContainsKey(j))
							md[j] = new MarketDepthLevel() { Price = j, Ask = 0, Bid = 0, Type = Side.Empty };

						summ += md[j].Volume;
					}

					AgregatedLevels.TryAdd(level, new MarketDepthLevel() { Price = level ,Ask = summ,Bid=0});
				}

				for (decimal i =bestbid.Price; i> minlevel; i -= agregation * secutityMain.PriceStep)
				{
					decimal summ = 0;
					decimal level = i;
					for (decimal j = i; j >= i - agregation * secutityMain.PriceStep; j -= secutityMain.PriceStep)
					{
						if (!md.ContainsKey(j))
							md[j] = new MarketDepthLevel() { Price = j, Ask = 0, Bid = 0, Type = Side.Empty };

						summ += md[j].Volume;
					}

					AgregatedLevels.TryAdd(level, new MarketDepthLevel() { Price = level, Ask = 0, Bid = summ,});
				}



			 }

			if (!agreagate)
			{
				

				Quotes = md.Values;
			}
			else
			{


				Quotes = AgregatedLevels.Values.OrderByDescending(s => s.Price);
			}

			//TODO - при масштабированини этот уровень лучше менять.
			maxchart = bestbid.Price + levelsFromBest * secutityMain.PriceStep;
			minchart = bestbid.Price - levelsFromBest * secutityMain.PriceStep;

			//Console.WriteLine($"MD recevied {secutityMain.id} NAME={secutityMain.Isin}");

			var dictionary = Quotes.Select(t => new { t.Price, t })
				.ToDictionary(t => t.Price, t => t);


			//int visibleitem = Grid.GetStartRowVisibleIndex();
			//Console.WriteLine("видимая строка " + Quotes.ToArray()[visibleitem].Price + $@"к1={Grid.GetVisibleRowCount()} к2={Quotes.Count()}");

			await InvokeAsync(() =>
			{
				try
				{
					/*
					orderbookcount++;



					if (orderbookcount < 3)
						{
						//Console.WriteLine($"{DateTime.Now} New Quotes!");
						if (dictionary.ContainsKey(maxchart))
							{
							Console.WriteLine($"Scroll to {maxchart}!");
							ScrollToLastRow1(dictionary[maxchart].t);
						}

						if (dictionary.ContainsKey(minchart))
							{
							Console.WriteLine($"Scroll to {minchart}!");
							ScrollToLastRow1(dictionary[minchart].t);
						}
					}*/

					StateHasChanged();
				}
				catch (Exception ex)
				{

				}
			});
		}
		catch (Exception ex)
		{

		}
	}



	/*------ временно -------------- */

	[Parameter]
	public int start { get; set; }
	[Parameter]
	public DateTime dt { get; set; }

	[Parameter]
	public int orderbookcount { get; set; }

	[Parameter]
	public decimal levelsFromBest { get; set; } = 20;

	[Parameter]
	public decimal minchart { get; set; }

	[Parameter]
	public decimal maxchart { get; set; }


	//---------------------------------//


	private async void OnNewTicks(string secinstrument, List<TradeApi> ticks)
	{
		if (secinstrument != secutityMain.id) return;

		Console.WriteLine(ticks[0].SecurityId + " new tick !" + ticks[0].Price);

		//Data.ProcessTick(ticks);

		DateTime lasttime = DateTime.Now;

		try
		{
			if (Ticks.Count != 0)
			{
				lasttime = Ticks[Ticks.Count - 1].Time;
			}
			else
			{
				lasttime = DateTime.Now;
			}
		}
		catch (Exception ex)
		{
			lasttime = DateTime.Now;
		}

		int counter = 0;
		foreach (var tick in ticks)
		{
			start++;
			counter++;


			//tick.Time = dt + TimeSpan.FromSeconds(start);
			tick.Time = lasttime + TimeSpan.FromSeconds(counter);

			Ticks.Add(tick);

			try
			{
				if (Ticks.Count > 15) Ticks.RemoveAt(0);
			}
			catch (Exception ex)
			{

			}
		}

		await InvokeAsync(() => { Chart.RefreshData(); });
	}



	[Parameter]
	public List<TradeApi> Ticks { get; set; }

	//TODO: Тут надо подумать конечно.
	void ScrollToLastRow1(MarketDepthLevel level)
	{
		Grid.MakeDataItemVisibleAsync(level);

		Console.WriteLine("visible row " + Grid.GetStartRowVisibleIndex());
	}

	void ScrollToLastRow(int count)
	{
		Console.WriteLine($"{count} scroll");
		Grid.MakeRowVisible(count);

	}

	void Grid_CustomizeElement(GridCustomizeElementEventArgs e)
	{

		if (e.ElementType == GridElementType.DataRow && (PlazaEngine.Entity.Side)e.Grid.GetRowValue(e.VisibleIndex, "Type") == Side.Sell)
		{
			e.CssClass = "highlighted-item";
		}

		if (e.ElementType == GridElementType.DataRow && (PlazaEngine.Entity.Side)e.Grid.GetRowValue(e.VisibleIndex, "Type") == Side.Buy)
		{
			e.CssClass = "highlighted-item2";
		}


	}

	protected void PrepareSeriesPoint(ChartSeriesPointCustomizationSettings pointSettings)
	{
		//всегда 1 элемент
		var t = (TradeApi)pointSettings.Point.DataItems.ToArray()[0];

		//показывать объём сверху
		pointSettings.PointLabel.Texts = new string[] { t.Volume.ToString() };
		pointSettings.PointLabel.Visible = true;

		//кружок
		pointSettings.PointAppearance.Symbol = ChartPointSymbol.Circle;

		//TODO: Исправить размеры - сделать адаптивными
		//TODO: написать логику расчета адаптивных элементов
		pointSettings.PointAppearance.Size = 1;

		if (t.Side == Side.Sell)
			pointSettings.PointAppearance.Color = Color.Red;
		else if (t.Side == Side.Buy)
			pointSettings.PointAppearance.Color = Color.Green;

	}


	async Task<Task> OnClosingMain()
	{
		ApiDataService.StopOrderBookProcesor(secutityMain.id);

		foreach (var webSocket in WebSockets)
		{
			try
			{
				var r = await webSocket.StopOrFail(WebSocketCloseStatus.NormalClosure, "Закрыта вкладка");

				if (!r)
				{

				}
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
			}
		}
		//TODO: Сделать отписку по инструментам и полный Dispose

		OnClosing?.Invoke(secutityMain);
		return Task.CompletedTask;
	}

	Orientation currentOrientation;
	IEnumerable<MarketDepthLevel> Quotes;

	string messageConnection { get; set; }
	public object GetColor { get; set; }



	void IDisposable.Dispose()
	{
		ApiDataService.NewMarketDepth -= OnNewMarketDepth;
		ApiDataService.NewTicks -= OnNewTicks;
	}
}

<script>
	function getScrollEvent() {
		let targetElements = document.querySelectorAll(".k-grid-content");

		targetElements.forEach(function (targetElement) {
			targetElement.addEventListener('scroll', (event) => {
				console.log("grid scrolling");
			});
		});
	}

</script>