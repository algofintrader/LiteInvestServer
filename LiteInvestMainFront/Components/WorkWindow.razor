
@using System.Drawing
@using System.Net.WebSockets
@using DevExpress.Data.Browsing
@using LiteInvestMainFront.Data
@using LiteInvestServer.Json
@using PlazaEngine.Entity
@using Websocket.Client
@using Orientation = DevExpress.Blazor.Orientation



<style>
	.cardnew {
		height: 800px;

	}

	.gridlayout-item {
		font-size: 1.2em;
		font-weight: 500;
		text-align: center;
		width: 100%;
		height: 800px;
		text-align: center;
		position: relative;
		z-index: 0;
		display: flex;
		align-items: start;
		justify-content: start;
	}
	.gridlayout-item:before {
		content: " ";
		position: absolute;
		z-index: -1;
		width: 100%;
		height: 100%;
		left: 0;
		top: 0;
		opacity: 0.4;
	}
	.gridlayout-header:before {
		background-color: var(--bs-red);
	}
	.gridlayout-content:before {
		background-color: var(--bs-yellow);
	}
	.gridlayout-left-side-bar:before {
		
		background-color: var(--bs-green);
	}
	.gridlayout-right-side-bar:before {
		
	}
	.gridlayout-footer:before {
		background-color: var(--bs-blue);
		opacity: 0.5;
	}
	
	.dxgrid {
		height: 100%;
		
	}
	
	.dxbl-grid 
	{
		--dxbl-grid-font-size: 10px;
	}

	.chart {
		height: 100%;
	}

	.highlighted-item > td {
		background-color: var(--bs-danger-bg-subtle)
	}

	.card-body{
		padding: 0;
	}

	.highlighted-item2 > td {
		background-color: var(--bs-success-bg-subtle)
	}

	
	
</style>


<div class="card cardnew">
			<div class="card-header">
				@secutityMain.Isin
				<button  type="button" class="buttonclose btn-close" aria-label="Close" @onclick="OnClosingMain" ></button>
			</div>
<div class="card-body">

	<DxGridLayout CssClass="w-100 ch-480">
		<Rows>
			<DxGridLayoutRow />
			<DxGridLayoutRow Height="auto" />
		</Rows>
		<Columns>
			<DxGridLayoutColumn  />
			<DxGridLayoutColumn  />
			<DxGridLayoutColumn />
		</Columns>
		<Items>
			<DxGridLayoutItem Row="0" Column="0">
				<Template>
					<div class="gridlayout-item">
						Clasters
					</div>
				</Template>
			</DxGridLayoutItem>

			<DxGridLayoutItem Row="0" Column="1">
				<Template>
					<div class=" gridlayout-item">
						<DxChart CssClass="chart"
						         CustomizeSeriesPoint="@PrepareSeriesPoint"
							@ref="Chart"
							Data="Ticks"
							Width="100%"
							LabelOverlap="ChartLabelOverlap.Hide">
							<DxChartLineSeries Name="ticksLineSeries"
							                  
							                   T="Trade"
							                   TArgument="DateTime"
							                   TValue="decimal"
							                   ArgumentField="si => si.Time"
							                   ValueField="si => si.Price"
							                   HoverMode="ChartContinuousSeriesHoverMode.Series">
								
								<DxChartLegend Visible="false" />
								
								<!--<DxChartSeriesPoint Visible="true"
												HoverMode="ChartSeriesPointHoverMode.None" />-->
								<!--<DxChartSeriesLabel Visible="true"
												ValueFormat="ChartElementFormat.Thousands(1)" />-->
							</DxChartLineSeries>
						
							<DxChartLegend Position="RelativePosition.Outside"
							               HorizontalAlignment="HorizontalAlignment.Right" />


								<DxChartArgumentAxis Visible="false">
									<DxChartAxisTick Visible="false" />
									<DxChartAxisMinorTick Visible="false" />
									<DxChartAxisGridLines Visible="true" />
									
									

								</DxChartArgumentAxis>

								<DxChartValueAxis Visible="false">

								<DxChartAxisTick Visible="false"/>
								<DxChartAxisMinorTick Visible="false"/>

								<DxChartAxisGridLines Visible="true"/>

								<DxChartAxisRange StartValue="@minchart" EndValue="@maxchart"/>
								</DxChartValueAxis>
						
							<!--
						<DxChartTooltip Enabled="true">
							@context.Point.Render((seriesPoint) =>
								@<div style="margin: 0.75rem">
									<div>@seriesPoint.SeriesName</div>
									<span>@($"{seriesPoint.Argument: MMMM yyyy}: ")</span>
									<span>@($"{seriesPoint.Value: $0,.0}K")</span>
								</div>
																)
						</DxChartTooltip>-->
						</DxChart>
					</div>
				</Template>
			</DxGridLayoutItem>
			
			<DxGridLayoutItem Row="0" Column="2">
				<Template>
					<div class=" gridlayout-item">
						<DxGrid CssClass="dxgrid"
						        @ref=Grid
						        Data="@Quotes"
						        ShowAllRows="true"
						        ColumnResizeMode="GridColumnResizeMode.NextColumn"
						        TextWrapEnabled="false"
						        CustomizeElement="Grid_CustomizeElement"
						        ShowGroupPanel="false"
						        HighlightRowOnHover="true"
								FocusedRowEnabled="true"
						        >

							<Columns>
								<DxGridDataColumn FieldName="Volume" Width="30px"/>
								<DxGridDataColumn FieldName="Price" Width="30px"/>
								<DxGridDataColumn FieldName="Type" Width="0" Visible="false"/>
							</Columns>
						</DxGrid>
					</div>
				</Template>
			</DxGridLayoutItem>
		</Items>
	</DxGridLayout>
</div>
</div>


@code {
	DxChart<Trade> Chart;

	IGrid Grid;
	//А вдруг у меня все получится
	//Влруг я буду прав

	List<Trade> Ticks { get; set; } = new List<Trade>();

	[Parameter]
	public Action<SecurityApi>? OnClosing { get; set; }

	[Parameter]
	public SecurityApi secutityMain { get; set; }

	[Parameter]
	public ApiDataService ApiDataService { get; set; }

	decimal minchart = 10000;
	decimal maxchart = 12000;

	public List<WebsocketClient> WebSockets { get; set; }

	int levelsFromBest = 20;

	int i = 1;
	int orderbookcount = 0;
	int start = 0;

	public DateTime dt { get; set; }

	protected override async Task<Task> OnInitializedAsync()
	{
		if (secutityMain== null)
			return base.OnInitializedAsync();

		WebSockets = new List<WebsocketClient>();

		dt = DateTime.Now;
		ApiDataService.NewMarketDepth += OnNewMarketDepth;
		ApiDataService.NewTicks += OnNewTicks;

		WebSockets.Add(await ApiDataService.SubscribeOrderBook(secutityMain.id));
		WebSockets.Add(await ApiDataService.SubcribeTick(secutityMain.id));

		return base.OnInitializedAsync();
	}

	private async void OnNewMarketDepth(MarketDepthLevel bestbid, string secinstrument, IEnumerable<MarketDepthLevel> md)
	{
		if (secinstrument != secutityMain.id) return;

		Quotes = md;

		//TODO - при масштабированини этот уровень лучше менять. 
		maxchart = bestbid.Price + levelsFromBest * secutityMain.PriceStep;
		minchart = bestbid.Price - levelsFromBest * secutityMain.PriceStep;

		var dictionary = Quotes.Select(t => new { t.Price, t })
			.ToDictionary(t => t.Price, t => t);


		//int visibleitem = Grid.GetStartRowVisibleIndex();
		//Console.WriteLine("видимая строка " + Quotes.ToArray()[visibleitem].Price + $@"к1={Grid.GetVisibleRowCount()} к2={Quotes.Count()}");

		await InvokeAsync(() =>
		{
			orderbookcount++;

			if (orderbookcount < 3)
			{
				//Console.WriteLine($"{DateTime.Now} New Quotes!");
				if (dictionary.ContainsKey(maxchart))
				{
					Console.WriteLine($"Scroll to {maxchart}!");
					ScrollToLastRow1(dictionary[maxchart].t);
				}

				if (dictionary.ContainsKey(minchart))
				{
					Console.WriteLine($"Scroll to {minchart}!");
					ScrollToLastRow1(dictionary[minchart].t);
				}
			}

			StateHasChanged();
		});
	}

	private async void OnNewTicks(string secinstrument, List<TradeApi> ticks)
	{
		if (secinstrument != secutityMain.id) return;

		Console.WriteLine(ticks[0].SecurityId + " new tick !" + ticks[0].Price);

		foreach (var tick in ticks)
		{
			start++;
			Ticks.Add(new Trade()
			{
				Price = tick.Price, //Quotes.ToArray()[new Random().Next(1, Quotes.Count())].Price,
				Time = dt + TimeSpan.FromSeconds(start),
				Volume = tick.Volume,
				Side = tick.Side
			});

			if (Ticks.Count > 15) Ticks.RemoveAt(0);
		}

		await InvokeAsync(() => { Chart.RefreshData(); });
	}


	//TODO: Тут надо подумать конечно.
	void ScrollToLastRow1(MarketDepthLevel level)
	{
		Grid.MakeDataItemVisibleAsync(level);

		Console.WriteLine("visible row " + Grid.GetStartRowVisibleIndex());
	}

	void ScrollToLastRow(int count)
	{
		Console.WriteLine($"{count} scroll");
		//Grid.(count);

	}

	void Grid_CustomizeElement(GridCustomizeElementEventArgs e)
	{

		if (e.ElementType == GridElementType.DataRow && (PlazaEngine.Entity.Side)e.Grid.GetRowValue(e.VisibleIndex, "Type") == Side.Sell)
		{
			e.CssClass = "highlighted-item";
		}

		if (e.ElementType == GridElementType.DataRow && (PlazaEngine.Entity.Side)e.Grid.GetRowValue(e.VisibleIndex, "Type") == Side.Buy)
		{
			e.CssClass = "highlighted-item2";
		}


	}

	protected void PrepareSeriesPoint(ChartSeriesPointCustomizationSettings pointSettings)
	{
		//всегда 1 элемент
		var t = (Trade)pointSettings.Point.DataItems.ToArray()[0];

		//показывать объём сверху
		pointSettings.PointLabel.Texts = new string[] { t.Volume.ToString() };
		pointSettings.PointLabel.Visible = true;

		//кружок
		pointSettings.PointAppearance.Symbol = ChartPointSymbol.Circle;

		//TODO: Исправить размеры - сделать адаптивными
		pointSettings.PointAppearance.Size = (int)t.Volume * 3;

		if (t.Side == Side.Sell)
			pointSettings.PointAppearance.Color = Color.Red;
		else if (t.Side == Side.Buy)
			pointSettings.PointAppearance.Color = Color.Green;

	}


	Task OnClosingMain()
	{
		ApiDataService.NewMarketDepth -= OnNewMarketDepth;
		ApiDataService.NewTicks -= OnNewTicks;

		foreach (var webSocket in WebSockets)
		{
			try
			{
				webSocket.Stop(WebSocketCloseStatus.NormalClosure, "Закрыта вкладка");
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
			}
		}
		//TODO: Сделать отписку по инструментам и полный Dispose

		OnClosing?.Invoke(secutityMain);
		return Task.CompletedTask;
	}

	Orientation currentOrientation;
	IEnumerable<MarketDepthLevel> Quotes;

	string messageConnection { get; set; }

}